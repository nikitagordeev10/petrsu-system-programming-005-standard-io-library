5. Стандартная библиотека ввода-вывода

Создайте аналог программы 3.1 (копирование файла) с использованием потоковых фунций fopen(), fread(), fwrite(), fclose().

Измерьте время работы предыдущей программы при чтении блоками по 1 байт, 1 Кб, 1 Мб, st_blksize из результата stat().
- Для получения корректных результатов при чтении блоками файл должен быть большим (удвоенный размер оперативной памяти, 6Гб для 241 ауд.);
- Тестовый файл должен находиться на локальном диске (не в сетевом домашнем каталоге);
- Для создания удобно использовать утилиту dd:

```
> dd if=/dev/zero of=/tmp/testfile bs=1M count=$[6*1024]
6144+0 записей получено
6144+0 записей отправлено
6442450944 байт (6,4 GB, 6,0 GiB) скопирован, 75,3644 s, 85,5 MB/s
```
- При измерении времени чтения по 1 байту используйте файл меньшего размера (например, 100Мб);
- Копируйте в /dev/null:
```
> ./a.out /tmp/testfile /dev/null
....
```
- Не забудьте удалить тестовый файл после окончания экспериментов;
- Не используйте функцию clock() для измерения времени, она меряет не общее время работы, а время, потраченное процессором. Время, потраченное на ввод-вывод при этом не учитывается.

Добавьте отключение буферизации в программу для предыдущего задания и проведите те же измерения с отключенной буферизацией. Сделайте выводы по результатам измерений в пп.2,3.

Создайте программу, в которой посимвольно с использованием фунции fgetc() читается указанный в командной строке файл, прочитанные символы выводятся в поток stdout, разделенные пробелами (например, для содержимого файла "Hello, world!" должно получиться "H e l l o , w o r l d ! "). Убедитесь, что, если файл содержит кириллицу в UTF-8, то результат получается некорректный.

Модифицируйте программу из предыдущего примера с использованием функции fgetwc(). Убедитесь, что программа корректно работает, если файл содержит символы в UTF-8.

Создайте программу для определения количества символов в строке UTF-8. Строка передается как аргумент командной строки.