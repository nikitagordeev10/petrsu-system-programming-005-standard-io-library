/**
 * task_2.c — программа копирования файлов с использованием потоковых фунций fopen(), fread(), fwrite(), fclose().
 * Программа должна получать три аргумента командной строки, первый аргумент - файл, откуда копировать, второй аргумент - файл, куда копировать, третий аргумент - размер блока.
 * Измерить время работы программы при чтении блоками по 1 байт, 1 Кб, 1 Мб, st_blksize из результата stat().
 * 
 * Ход работы:
 * 1) Для получения корректных результатов при чтении блоками файл должен быть большим (удвоенный размер оперативной памяти, 6Гб для 241 ауд.);
 * 2) Тестовый файл должен находиться на локальном диске (не в сетевом домашнем каталоге);
 * 3) Для создания удобно использовать утилиту dd: dd if=/dev/zero of=/tmp/testfile bs=1M count=$[6*1024]
 * 4) При измерении времени чтения по 1 байту используйте файл меньшего размера (например, 100Мб);
 * 5) Копируйте в /dev/null: ./a.out /tmp/testfile /dev/null
 * 6) Не забудьте удалить тестовый файл после окончания экспериментов;
 * 7) Не используйте функцию clock() для измерения времени, она меряет не общее время работы, а время, потраченное процессором. Время, потраченное на ввод-вывод при этом не учитывается.
 *
 * Copyright (c) <2022> <Гордеев Никита>
 *
 * This code is licensed under a MIT-style license.
 */


#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>

#define B 1
#define K 1024
#define M 1024*1024

void file_copying (const char *argv1, const char *argv2, const int BUFSIZE);

int main(int argc, char **argv)
{
    if (argc != 3) {
        printf("Недостаточно аргументов\n");
        printf("Первый аргумент - файл, откуда копировать, второй аргумент - файл, куда копировать\n");
        exit(EXIT_FAILURE);
    }

    /* Проверяем, можно ли получить сведения о файле через lstat */
    struct stat buf;
    if (lstat(argv[1], &buf) < 0) {
        printf("Ошибка lstat!\n");
        exit(EXIT_FAILURE);
    }

    /* Запускаем копирование несколькими блоками с подсчётом времени для каждого */
    file_copying(argv[1], argv[2], B);
    file_copying(argv[1], argv[2], K);
    file_copying(argv[1], argv[2], M);
    file_copying(argv[1], argv[2], buf.st_blksize);

    /* Успешное завершение программы */
    return 0;
}

void file_copying (const char *argv1, const char *argv2, const int BUFSIZE)
{
    FILE *f1, *f2;    
    
    /* Первый аргумент - файл, откуда копировать */
    if ((f1 = fopen(argv1, "r")) == NULL) {
        printf("Первый файл недоступен\n");
        exit(EXIT_FAILURE);
    }

    /* Второй аргумент - файл, куда копировать */
    if ((f2 = fopen(argv2, "w")) == NULL) {
        printf("Второй файл недоступен\n");
        exit(EXIT_FAILURE);
    }

    /* Чтение из первого файла и запись во второй файл */
    time_t time_start = time(NULL);
    int status;
    char buf[BUFSIZE];
    while ((status = fread(buf, sizeof(char), BUFSIZE, f1)) > 0) {
        if (fwrite(buf, sizeof(char), status, f2) != status) {
            printf("Ошибка записи во второй файл!\n");
            exit(EXIT_FAILURE);
        }
    }
    time_t time_end = time(NULL);

    /* Проверка закрытия первого файла */
    if (fclose(f1) == EOF) {
        printf("Ошибка закрытия первого файла!\n");
        exit(EXIT_FAILURE);
    }

    /* Проверка закрытия второго файла */
    if (fclose(f2) == EOF) {
        printf("Ошибка закрытия второго файла!\n");
        exit(EXIT_FAILURE);
    }

    printf("Время работы программы при размере буфера в %d байт: %ld секунд\n", BUFSIZE, time_end - time_start);
}

/* Материалы:
 * У. Ричард Стивенс, Стивен А. Раго Листинг 5.3. Вывод сведений о буферизации для различных потоков ввода/вывода // UNIX. Профессиональное программирование. - 2018. - С. 217-219.
 * У. Ричард Стивенс, Стивен А. Раго Листинг 8.17. Вывод учетной информации из системного файла учетных данных // UNIX. Профессиональное программирование. - 2018. - С. 334-335.
 * У. Ричард Стивенс, Стивен А. Раго Листинг 15.5. Функции popen и pclose // UNIX. Профессиональное программирование. - 2018. - С. 625-626.
 */
